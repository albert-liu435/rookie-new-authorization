授权码模式:
请求流程authorization_code.png




1、在浏览器中输入如下url
    http://127.0.0.1:8080/oauth2/authorize?client_id=messaging-client&response_type=code&scope=message.read&redirect_uri=https://www.baidu.com
    1.1、OAuth2AuthorizationEndpointFilter
        1.1.1 首先判断是否匹配uri,默认为/oauth2/authorize，匹配则进行处理，不匹配则进入下一个Filter
        1.1.2 委托类DelegatingAuthenticationConverter进行将请求转换为Authentication(OAuth2AuthorizationCodeRequestAuthenticationToken)，默认由OAuth2AuthorizationCodeRequestAuthenticationConverter处理
            进行匹配判断,然后获取所有所有的请求参数
            获取请求参数response_type，这里为code,并进行判断，如果为空或者参数个数不为1，或者参数值不为code,则抛出异常
            获取uri,这里为http://127.0.0.1:8080/oauth2/authorize
            获取请求参数client_id，这里为messaging-client,如果为空或者参数个数不为1,则抛出异常
            获取Authentication，因为是第一次请求，所以为null,然后设置为AnonymousAuthenticationToken("anonymous", "anonymousUser", AuthorityUtils.createAuthorityList("ROLE_ANONYMOUS"))
            获取请求参数redirect_uri，这里为https://www.baidu.com
            获取请求参数scope，如果多个的话，在请求url上面用空格分隔
            获取请求参数state，这里为空,获取请求参数code_challenge，这里为空，获取请求参数code_challenge_method,这里为空,获取其他额外参数
            将上面获取到的参数封装到OAuth2AuthorizationCodeRequestAuthenticationToken中并返回
        1.1.3 判断OAuth2AuthorizationCodeRequestAuthenticationToken是否为AbstractAuthenticationToken或者子类，如果是的话，就向Authentication中设置AuthenticationDetailsSource，默认为WebAuthenticationDetailsSource，里面封装了ip和sessionID
        1.1.4 ProviderManager 进行身份验证，会委托给OAuth2AuthorizationCodeRequestAuthenticationProvider进行处理
            通过registeredClientRepository查询出ID为messaging-client的RegisteredClient,然后构建		OAuth2AuthorizationCodeRequestAuthenticationContext authenticationContext,里面封装了RegisteredClient和OAuth2AuthorizationCodeRequestAuthenticationToken，并对OAuth2AuthorizationCodeRequestAuthenticationContext进行校验
            获取code_challenge，这里为空
            判断Authentication principal是否验证过，这里为AnonymousAuthenticationToken，也就是没有验证过，所以会将OAuth2AuthorizationCodeRequestAuthenticationToken返回
        1.1.5 由于是匿名访问，所以会进入到下一个过滤器中
    1.2 ExceptionTranslationFilter
        由于是匿名访问，经过前面的过滤器后，最终会进入到ExceptionTranslationFilter#handleSpringSecurityException()方法进行处理
        1.2.1   handleSpringSecurityException方法进行处理的时候，抛出的异常为AuthenticationException类型，所以会进入到handleAuthenticationException
        1.2.3   将该请求保存到session中，并进行重定向到登录页面

2、在登陆页面输入账号和密码
    admin,123456
    2.1 UsernamePasswordAuthenticationFilter
        2.1.1   http://127.0.0.1:8080/login进行登录,会通过UsernamePasswordAuthenticationFilter过滤器进行验证用户名和密码,验证通过
        2.1.2   successfulAuthentication()方法，通过调用SavedRequestAwareAuthenticationSuccessHandler#onAuthenticationSuccess(),从session中获取SavedRequest,默认为DefaultSavedRequest,里面封装了上次请求的信息，然后获取targetUrl:http://127.0.0.1:8080/oauth2/authorize?client_id=messaging-client&response_type=code&scope=message.read&redirect_uri=https://www.baidu.com&continue,进行重定向操作

3、重定向到http://127.0.0.1:8080/oauth2/authorize?client_id=messaging-client&response_type=code&scope=message.read&redirect_uri=https://www.baidu.com&continue
    这次进行请求的时候，由于这次已经经过了身份认证，所以会通过,然后经过OAuth2AuthorizationEndpointFilter
    3.1 OAuth2AuthorizationEndpointFilter
        3.1.1   会重新执行上面的1.1的流程
        3.1.2   ProviderManager 进行身份验证，会委托给OAuth2AuthorizationCodeRequestAuthenticationProvider进行处理
            通过registeredClientRepository查询出ID为messaging-client的RegisteredClient,然后构建		OAuth2AuthorizationCodeRequestAuthenticationContext authenticationContext,里面封装了RegisteredClient和OAuth2AuthorizationCodeRequestAuthenticationToken，并对OAuth2AuthorizationCodeRequestAuthenticationContext进行校验。获取code_challenge，这里为空
            判断Authentication principal是否验证过，此时已经验证通过，将OAuth2AuthorizationCodeRequestAuthenticationToken里面的信息封装到OAuth2AuthorizationRequest中,然后根据 registeredClientId和principalName,registeredClientId为oauth2_registered_client,其中记录messaging-client唯一ID,principalName为登录账号账号admin，查询oauth2_authorization_consent表是否存在，然后进行校验，校验通过进行下一步
        3.1.3   根据OAuth2AuthorizationCodeRequestAuthenticationToken，registeredClient,scope,封装OAuth2TokenContext，然后通过OAuth2AuthorizationCodeGenerator#generate()方法生成OAuth2AuthorizationCode，里面包含生成code的值和有效期,并将该信息保存到oauth2_authorization中，然后封装OAuth2AuthorizationCodeRequestAuthenticationToken，里面包含重定向信息和code值并返回，最终调用sendAuthorizationResponse方法进行重定向到https://www.baidu.com

//TODO

    进行请求的时候，由于这次已经经过了身份认证，所以会通过,然后经过OAuth2AuthorizationEndpointFilter#sendAuthorizationConsent()方法进行处理,展示consentPage页面,当全选中message.read并提交的时候,会再次通过OAuth2AuthorizationEndpointFilter过滤器
4、进行提交操作http://127.0.0.1:8080/oauth2/authorize,
        通过OAuth2AuthorizationEndpointFilter过滤,此时通过OAuth2AuthorizationConsentAuthenticationConverter进行转换，转换为OAuth2AuthorizationConsentAuthenticationToken,这个里面包含了所需要的code,然后通过OAuth2AuthorizationEndpointFilter#sendAuthorizationResponse方法进行重定向，重定向后的会携带code在url后面
5、使用postman进行换取token
    post请求：http://127.0.0.1:8080/oauth2/token,
    通过OAuth2ClientAuthenticationFilter过滤器，通过ClientSecretBasicAuthenticationConverter进行转换OAuth2ClientAuthenticationToken，OAuth2ClientAuthenticationToken存储的username和password已经解析成了明文然后并经过ClientSecretAuthenticationProvider验证后生成OAuth2ClientAuthenticationToken。然后通过OAuth2TokenEndpointFilter过滤器，由OAuth2AuthorizationCodeAuthenticationConverter将请求转换为OAuth2AuthorizationCodeAuthenticationToken，然后通过OAuth2AuthorizationCodeAuthenticationProvider进行身份验证，验证通过就进行生成OAuth2AccessTokenAuthenticationToken，里面包含accesstoken和refreshtoken，并返回给客户端
6、携带token进行请求
        会通过BearerTokenAuthenticationFilter过滤器，然后进行JwtAuthenticationProvider验证，验证通过后再进行scope验证，就可以访问到资源了


第一次请求的时候，最终会通过OAuth2AuthorizationCodeRequestAuthenticationConverter中集合中的OAuth2AuthorizationCodeRequestAuthenticationConverter进行转换，
OAuth2AuthorizationCodeRequestAuthenticationConverter的主要作用为尝试从HttpServletRequest提取OAuth 2.0授权代码授予的授权请求，然后将其转换为用于对请求进行身份验证的OAuth2AuthorizationCodeRequestAuthenticationToken
主要转换流程如下

	@Override
	public Authentication convert(HttpServletRequest request) {
	    //判断
		if (!"GET".equals(request.getMethod()) && !OIDC_REQUEST_MATCHER.matches(request)) {
			return null;
		}
        //获取请求参数 主要为client_id,response_type,scope,redirect_uri
		MultiValueMap<String, String> parameters = OAuth2EndpointUtils.getParameters(request);
        //获取response_type,这里为code
		// response_type (REQUIRED)
		String responseType = request.getParameter(OAuth2ParameterNames.RESPONSE_TYPE);
		//进行校验，不符合规则的话就直接抛出异常
		if (!StringUtils.hasText(responseType) ||
				parameters.get(OAuth2ParameterNames.RESPONSE_TYPE).size() != 1) {
			throwError(OAuth2ErrorCodes.INVALID_REQUEST, OAuth2ParameterNames.RESPONSE_TYPE);
		} else if (!responseType.equals(OAuth2AuthorizationResponseType.CODE.getValue())) {
			throwError(OAuth2ErrorCodes.UNSUPPORTED_RESPONSE_TYPE, OAuth2ParameterNames.RESPONSE_TYPE);
		}
        //获取请求uri
		String authorizationUri = request.getRequestURL().toString();

		// client_id (REQUIRED)
		String clientId = parameters.getFirst(OAuth2ParameterNames.CLIENT_ID);
		//校验client_id
		if (!StringUtils.hasText(clientId) ||
				parameters.get(OAuth2ParameterNames.CLIENT_ID).size() != 1) {
			throwError(OAuth2ErrorCodes.INVALID_REQUEST, OAuth2ParameterNames.CLIENT_ID);
		}
        //获取Authentication，第一次请求为null，所以会赋值AnonymousAuthenticationToken
		Authentication principal = SecurityContextHolder.getContext().getAuthentication();
		if (principal == null) {
			principal = ANONYMOUS_AUTHENTICATION;
		}

        //获取redirect_uri并校验
		// redirect_uri (OPTIONAL)
		String redirectUri = parameters.getFirst(OAuth2ParameterNames.REDIRECT_URI);
		if (StringUtils.hasText(redirectUri) &&
				parameters.get(OAuth2ParameterNames.REDIRECT_URI).size() != 1) {
			throwError(OAuth2ErrorCodes.INVALID_REQUEST, OAuth2ParameterNames.REDIRECT_URI);
		}

        //获取scope并校验
		// scope (OPTIONAL)
		Set<String> scopes = null;
		String scope = parameters.getFirst(OAuth2ParameterNames.SCOPE);
		if (StringUtils.hasText(scope) &&
				parameters.get(OAuth2ParameterNames.SCOPE).size() != 1) {
			throwError(OAuth2ErrorCodes.INVALID_REQUEST, OAuth2ParameterNames.SCOPE);
		}
		if (StringUtils.hasText(scope)) {
			scopes = new HashSet<>(
					Arrays.asList(StringUtils.delimitedListToStringArray(scope, " ")));
		}

		// state (RECOMMENDED)
		String state = parameters.getFirst(OAuth2ParameterNames.STATE);
		if (StringUtils.hasText(state) &&
				parameters.get(OAuth2ParameterNames.STATE).size() != 1) {
			throwError(OAuth2ErrorCodes.INVALID_REQUEST, OAuth2ParameterNames.STATE);
		}

        //获取code_challenge,用于PKCE
		// code_challenge (REQUIRED for public clients) - RFC 7636 (PKCE)
		String codeChallenge = parameters.getFirst(PkceParameterNames.CODE_CHALLENGE);
		if (StringUtils.hasText(codeChallenge) &&
				parameters.get(PkceParameterNames.CODE_CHALLENGE).size() != 1) {
			throwError(OAuth2ErrorCodes.INVALID_REQUEST, PkceParameterNames.CODE_CHALLENGE, PKCE_ERROR_URI);
		}

		// code_challenge_method (OPTIONAL for public clients) - RFC 7636 (PKCE)
		String codeChallengeMethod = parameters.getFirst(PkceParameterNames.CODE_CHALLENGE_METHOD);
		if (StringUtils.hasText(codeChallengeMethod) &&
				parameters.get(PkceParameterNames.CODE_CHALLENGE_METHOD).size() != 1) {
			throwError(OAuth2ErrorCodes.INVALID_REQUEST, PkceParameterNames.CODE_CHALLENGE_METHOD, PKCE_ERROR_URI);
		}

        //添加额外参数
		Map<String, Object> additionalParameters = new HashMap<>();
		parameters.forEach((key, value) -> {
			if (!key.equals(OAuth2ParameterNames.RESPONSE_TYPE) &&
					!key.equals(OAuth2ParameterNames.CLIENT_ID) &&
					!key.equals(OAuth2ParameterNames.REDIRECT_URI) &&
					!key.equals(OAuth2ParameterNames.SCOPE) &&
					!key.equals(OAuth2ParameterNames.STATE)) {
				additionalParameters.put(key, value.get(0));
			}
		});
        //生成OAuth2AuthorizationCodeRequestAuthenticationToken
		return new OAuth2AuthorizationCodeRequestAuthenticationToken(authorizationUri, clientId, principal,
				redirectUri, state, scopes, additionalParameters);
	}

然后进行身份验证,身份验证最终会通过OAuth2AuthorizationCodeRequestAuthenticationProvider进行
由于OAuth2AuthorizationCodeRequestAuthenticationToken里面封装的ANONYMOUS_AUTHENTICATION,所以会验证失败
主要流程如下：
	@Override
	public Authentication authenticate(Authentication authentication) throws AuthenticationException {
	    //强制转换为OAuth2AuthorizationCodeRequestAuthenticationToken
		OAuth2AuthorizationCodeRequestAuthenticationToken authorizationCodeRequestAuthentication =
				(OAuth2AuthorizationCodeRequestAuthenticationToken) authentication;

        //通过ClientId获取RegisteredClient
		RegisteredClient registeredClient = this.registeredClientRepository.findByClientId(
				authorizationCodeRequestAuthentication.getClientId());
		if (registeredClient == null) {
			throwError(OAuth2ErrorCodes.INVALID_REQUEST, OAuth2ParameterNames.CLIENT_ID,
					authorizationCodeRequestAuthentication, null);
		}

		if (this.logger.isTraceEnabled()) {
			this.logger.trace("Retrieved registered client");
		}
        //构建OAuth2AuthorizationCodeRequestAuthenticationContext
		OAuth2AuthorizationCodeRequestAuthenticationContext authenticationContext =
				OAuth2AuthorizationCodeRequestAuthenticationContext.with(authorizationCodeRequestAuthentication)
						.registeredClient(registeredClient)
						.build();
						//对OAuth2AuthorizationCodeRequestAuthenticationContext进行校验
		this.authenticationValidator.accept(authenticationContext);

		if (!registeredClient.getAuthorizationGrantTypes().contains(AuthorizationGrantType.AUTHORIZATION_CODE)) {
			throwError(OAuth2ErrorCodes.UNAUTHORIZED_CLIENT, OAuth2ParameterNames.CLIENT_ID,
					authorizationCodeRequestAuthentication, registeredClient);
		}

		// code_challenge (REQUIRED for public clients) - RFC 7636 (PKCE)
		String codeChallenge = (String) authorizationCodeRequestAuthentication.getAdditionalParameters().get(PkceParameterNames.CODE_CHALLENGE);
		if (StringUtils.hasText(codeChallenge)) {
			String codeChallengeMethod = (String) authorizationCodeRequestAuthentication.getAdditionalParameters().get(PkceParameterNames.CODE_CHALLENGE_METHOD);
			if (!StringUtils.hasText(codeChallengeMethod) || !"S256".equals(codeChallengeMethod)) {
				throwError(OAuth2ErrorCodes.INVALID_REQUEST, PkceParameterNames.CODE_CHALLENGE_METHOD, PKCE_ERROR_URI,
						authorizationCodeRequestAuthentication, registeredClient, null);
			}
		} else if (registeredClient.getClientSettings().isRequireProofKey()) {
			throwError(OAuth2ErrorCodes.INVALID_REQUEST, PkceParameterNames.CODE_CHALLENGE, PKCE_ERROR_URI,
					authorizationCodeRequestAuthentication, registeredClient, null);
		}

		if (this.logger.isTraceEnabled()) {
			this.logger.trace("Validated authorization code request parameters");
		}

		// ---------------
		// The request is valid - ensure the resource owner is authenticated
		// ---------------

        //获取凭证,由于第一次请求为匿名AnonymousAuthenticationToken，所以直接返回OAuth2AuthorizationCodeRequestAuthenticationToken
		Authentication principal = (Authentication) authorizationCodeRequestAuthentication.getPrincipal();
		if (!isPrincipalAuthenticated(principal)) {
			if (this.logger.isTraceEnabled()) {
				this.logger.trace("Did not authenticate authorization code request since principal not authenticated");
			}
			// Return the authorization request as-is where isAuthenticated() is false
			return authorizationCodeRequestAuthentication;
		}

        //当第二次输入账号密码时，进行创建OAuth2AuthorizationRequest
		OAuth2AuthorizationRequest authorizationRequest = OAuth2AuthorizationRequest.authorizationCode()
				.authorizationUri(authorizationCodeRequestAuthentication.getAuthorizationUri())
				.clientId(registeredClient.getClientId())
				.redirectUri(authorizationCodeRequestAuthentication.getRedirectUri())
				.scopes(authorizationCodeRequestAuthentication.getScopes())
				.state(authorizationCodeRequestAuthentication.getState())
				.additionalParameters(authorizationCodeRequestAuthentication.getAdditionalParameters())
				.build();

		OAuth2AuthorizationConsent currentAuthorizationConsent = this.authorizationConsentService.findById(
				registeredClient.getId(), principal.getName());

		if (requireAuthorizationConsent(registeredClient, authorizationRequest, currentAuthorizationConsent)) {
		    //生成
			String state = DEFAULT_STATE_GENERATOR.generateKey();
			OAuth2Authorization authorization = authorizationBuilder(registeredClient, principal, authorizationRequest)
					.attribute(OAuth2ParameterNames.STATE, state)
					.build();

			if (this.logger.isTraceEnabled()) {
				logger.trace("Generated authorization consent state");
			}

			this.authorizationService.save(authorization);

			Set<String> currentAuthorizedScopes = currentAuthorizationConsent != null ?
					currentAuthorizationConsent.getScopes() : null;

			if (this.logger.isTraceEnabled()) {
				this.logger.trace("Saved authorization");
			}
            //返回OAuth2AuthorizationConsentAuthenticationToken
			return new OAuth2AuthorizationConsentAuthenticationToken(authorizationRequest.getAuthorizationUri(),
					registeredClient.getClientId(), principal, state, currentAuthorizedScopes, null);
		}

		OAuth2TokenContext tokenContext = createAuthorizationCodeTokenContext(
				authorizationCodeRequestAuthentication, registeredClient, null, authorizationRequest.getScopes());
		OAuth2AuthorizationCode authorizationCode = this.authorizationCodeGenerator.generate(tokenContext);
		if (authorizationCode == null) {
			OAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.SERVER_ERROR,
					"The token generator failed to generate the authorization code.", ERROR_URI);
			throw new OAuth2AuthorizationCodeRequestAuthenticationException(error, null);
		}

		if (this.logger.isTraceEnabled()) {
			this.logger.trace("Generated authorization code");
		}

		OAuth2Authorization authorization = authorizationBuilder(registeredClient, principal, authorizationRequest)
				.authorizedScopes(authorizationRequest.getScopes())
				.token(authorizationCode)
				.build();
		this.authorizationService.save(authorization);

		if (this.logger.isTraceEnabled()) {
			this.logger.trace("Saved authorization");
		}

		String redirectUri = authorizationRequest.getRedirectUri();
		if (!StringUtils.hasText(redirectUri)) {
			redirectUri = registeredClient.getRedirectUris().iterator().next();
		}

		if (this.logger.isTraceEnabled()) {
			this.logger.trace("Authenticated authorization code request");
		}

		return new OAuth2AuthorizationCodeRequestAuthenticationToken(authorizationRequest.getAuthorizationUri(),
				registeredClient.getClientId(), principal, authorizationCode, redirectUri,
				authorizationRequest.getState(), authorizationRequest.getScopes());
	}

认证失败后，通过ExceptionTranslationFilter进行处理异常,最终调用sendStartAuthentication方法，由LoginUrlAuthenticationEntryPoint进行处理跳转到登陆页面,
输入账号密码后会进行第二次进入到OAuth2AuthorizationEndpointFilter过滤器中,
然后调用OAuth2AuthorizationCodeRequestAuthenticationConverter#convert()方法，此时返回的OAuth2AuthorizationCodeRequestAuthenticationToken中封装的为UsernamePasswordAuthenticationToken，然后进行第二次OAuth2AuthorizationCodeRequestAuthenticationProvider#authenticate()验证,最终返回OAuth2AuthorizationConsentAuthenticationToken。最终调用
OAuth2AuthorizationEndpointFilter#sendAuthorizationConsent()方法，该实例会重定向到http://127.0.0.1:8080/oauth2/consent?scope=message.read&client_id=messaging-client&state=rADng5pYMB7FA7yIG72qis4G-MBlK3hr8AoLycQmDdU%3D

如图1722496440753.png当提交时，会再次进入到OAuth2AuthorizationEndpointFilter过滤器，并就进入到OAuth2AuthorizationCodeRequestAuthenticationConverter进行处理返回null,最终进入到OAuth2AuthorizationConsentAuthenticationConverter中进行处理
如下：
	@Override
	public Authentication convert(HttpServletRequest request) {
		if (!"POST".equals(request.getMethod()) ||
				request.getParameter(OAuth2ParameterNames.RESPONSE_TYPE) != null) {
			return null;
		}
        //获取参数
		MultiValueMap<String, String> parameters = OAuth2EndpointUtils.getParameters(request);

		String authorizationUri = request.getRequestURL().toString();

		// client_id (REQUIRED)
		String clientId = parameters.getFirst(OAuth2ParameterNames.CLIENT_ID);
		if (!StringUtils.hasText(clientId) ||
				parameters.get(OAuth2ParameterNames.CLIENT_ID).size() != 1) {
			throwError(OAuth2ErrorCodes.INVALID_REQUEST, OAuth2ParameterNames.CLIENT_ID);
		}
        //获取凭证
		Authentication principal = SecurityContextHolder.getContext().getAuthentication();
		if (principal == null) {
			principal = ANONYMOUS_AUTHENTICATION;
		}

		// state (REQUIRED)
		String state = parameters.getFirst(OAuth2ParameterNames.STATE);
		if (!StringUtils.hasText(state) ||
				parameters.get(OAuth2ParameterNames.STATE).size() != 1) {
			throwError(OAuth2ErrorCodes.INVALID_REQUEST, OAuth2ParameterNames.STATE);
		}

		// scope (OPTIONAL)
		Set<String> scopes = null;
		if (parameters.containsKey(OAuth2ParameterNames.SCOPE)) {
			scopes = new HashSet<>(parameters.get(OAuth2ParameterNames.SCOPE));
		}

		Map<String, Object> additionalParameters = new HashMap<>();
		parameters.forEach((key, value) -> {
			if (!key.equals(OAuth2ParameterNames.CLIENT_ID) &&
					!key.equals(OAuth2ParameterNames.STATE) &&
					!key.equals(OAuth2ParameterNames.SCOPE)) {
				additionalParameters.put(key, value.get(0));
			}
		});

		return new OAuth2AuthorizationConsentAuthenticationToken(authorizationUri, clientId, principal,
				state, scopes, additionalParameters);
	}

最终生成OAuth2AuthorizationConsentAuthenticationToken返回，此时会通过OAuth2AuthorizationConsentAuthenticationProvider进行验证，如下
	@Override
	public Authentication authenticate(Authentication authentication) throws AuthenticationException {
		if (authentication instanceof OAuth2DeviceAuthorizationConsentAuthenticationToken) {
			// This is NOT an OAuth 2.0 Authorization Consent for the Authorization Code Grant,
			// return null and let OAuth2DeviceAuthorizationConsentAuthenticationProvider handle it instead
			return null;
		}

		OAuth2AuthorizationConsentAuthenticationToken authorizationConsentAuthentication =
				(OAuth2AuthorizationConsentAuthenticationToken) authentication;

		OAuth2Authorization authorization = this.authorizationService.findByToken(
				authorizationConsentAuthentication.getState(), STATE_TOKEN_TYPE);
		if (authorization == null) {
			throwError(OAuth2ErrorCodes.INVALID_REQUEST, OAuth2ParameterNames.STATE,
					authorizationConsentAuthentication, null, null);
		}

		if (this.logger.isTraceEnabled()) {
			this.logger.trace("Retrieved authorization with authorization consent state");
		}

		// The 'in-flight' authorization must be associated to the current principal
		Authentication principal = (Authentication) authorizationConsentAuthentication.getPrincipal();
		if (!isPrincipalAuthenticated(principal) || !principal.getName().equals(authorization.getPrincipalName())) {
			throwError(OAuth2ErrorCodes.INVALID_REQUEST, OAuth2ParameterNames.STATE,
					authorizationConsentAuthentication, null, null);
		}

		RegisteredClient registeredClient = this.registeredClientRepository.findByClientId(
				authorizationConsentAuthentication.getClientId());
		if (registeredClient == null || !registeredClient.getId().equals(authorization.getRegisteredClientId())) {
			throwError(OAuth2ErrorCodes.INVALID_REQUEST, OAuth2ParameterNames.CLIENT_ID,
					authorizationConsentAuthentication, registeredClient, null);
		}

		if (this.logger.isTraceEnabled()) {
			this.logger.trace("Retrieved registered client");
		}

		OAuth2AuthorizationRequest authorizationRequest = authorization.getAttribute(OAuth2AuthorizationRequest.class.getName());
		Set<String> requestedScopes = authorizationRequest.getScopes();
		Set<String> authorizedScopes = new HashSet<>(authorizationConsentAuthentication.getScopes());
		if (!requestedScopes.containsAll(authorizedScopes)) {
			throwError(OAuth2ErrorCodes.INVALID_SCOPE, OAuth2ParameterNames.SCOPE,
					authorizationConsentAuthentication, registeredClient, authorizationRequest);
		}

		if (this.logger.isTraceEnabled()) {
			this.logger.trace("Validated authorization consent request parameters");
		}

		OAuth2AuthorizationConsent currentAuthorizationConsent = this.authorizationConsentService.findById(
				authorization.getRegisteredClientId(), authorization.getPrincipalName());
		Set<String> currentAuthorizedScopes = currentAuthorizationConsent != null ?
				currentAuthorizationConsent.getScopes() : Collections.emptySet();

		if (!currentAuthorizedScopes.isEmpty()) {
			for (String requestedScope : requestedScopes) {
				if (currentAuthorizedScopes.contains(requestedScope)) {
					authorizedScopes.add(requestedScope);
				}
			}
		}

		if (!authorizedScopes.isEmpty() && requestedScopes.contains(OidcScopes.OPENID)) {
			// 'openid' scope is auto-approved as it does not require consent
			authorizedScopes.add(OidcScopes.OPENID);
		}

		OAuth2AuthorizationConsent.Builder authorizationConsentBuilder;
		if (currentAuthorizationConsent != null) {
			if (this.logger.isTraceEnabled()) {
				this.logger.trace("Retrieved existing authorization consent");
			}
			authorizationConsentBuilder = OAuth2AuthorizationConsent.from(currentAuthorizationConsent);
		} else {
			authorizationConsentBuilder = OAuth2AuthorizationConsent.withId(
					authorization.getRegisteredClientId(), authorization.getPrincipalName());
		}
		authorizedScopes.forEach(authorizationConsentBuilder::scope);

		if (this.authorizationConsentCustomizer != null) {
			// @formatter:off
			OAuth2AuthorizationConsentAuthenticationContext authorizationConsentAuthenticationContext =
					OAuth2AuthorizationConsentAuthenticationContext.with(authorizationConsentAuthentication)
							.authorizationConsent(authorizationConsentBuilder)
							.registeredClient(registeredClient)
							.authorization(authorization)
							.authorizationRequest(authorizationRequest)
							.build();
			// @formatter:on
			this.authorizationConsentCustomizer.accept(authorizationConsentAuthenticationContext);
			if (this.logger.isTraceEnabled()) {
				this.logger.trace("Customized authorization consent");
			}
		}

		Set<GrantedAuthority> authorities = new HashSet<>();
		authorizationConsentBuilder.authorities(authorities::addAll);

		if (authorities.isEmpty()) {
			// Authorization consent denied (or revoked)
			if (currentAuthorizationConsent != null) {
				this.authorizationConsentService.remove(currentAuthorizationConsent);
				if (this.logger.isTraceEnabled()) {
					this.logger.trace("Revoked authorization consent");
				}
			}
			this.authorizationService.remove(authorization);
			if (this.logger.isTraceEnabled()) {
				this.logger.trace("Removed authorization");
			}
			throwError(OAuth2ErrorCodes.ACCESS_DENIED, OAuth2ParameterNames.CLIENT_ID,
					authorizationConsentAuthentication, registeredClient, authorizationRequest);
		}

		OAuth2AuthorizationConsent authorizationConsent = authorizationConsentBuilder.build();
		if (!authorizationConsent.equals(currentAuthorizationConsent)) {
			this.authorizationConsentService.save(authorizationConsent);
			if (this.logger.isTraceEnabled()) {
				this.logger.trace("Saved authorization consent");
			}
		}

		OAuth2TokenContext tokenContext = createAuthorizationCodeTokenContext(
				authorizationConsentAuthentication, registeredClient, authorization, authorizedScopes);
		OAuth2AuthorizationCode authorizationCode = this.authorizationCodeGenerator.generate(tokenContext);
		if (authorizationCode == null) {
			OAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.SERVER_ERROR,
					"The token generator failed to generate the authorization code.", ERROR_URI);
			throw new OAuth2AuthorizationCodeRequestAuthenticationException(error, null);
		}

		if (this.logger.isTraceEnabled()) {
			this.logger.trace("Generated authorization code");
		}

		OAuth2Authorization updatedAuthorization = OAuth2Authorization.from(authorization)
				.authorizedScopes(authorizedScopes)
				.token(authorizationCode)
				.attributes(attrs -> {
					attrs.remove(OAuth2ParameterNames.STATE);
				})
				.build();
		this.authorizationService.save(updatedAuthorization);

		if (this.logger.isTraceEnabled()) {
			this.logger.trace("Saved authorization");
		}

		String redirectUri = authorizationRequest.getRedirectUri();
		if (!StringUtils.hasText(redirectUri)) {
			redirectUri = registeredClient.getRedirectUris().iterator().next();
		}

		if (this.logger.isTraceEnabled()) {
			this.logger.trace("Authenticated authorization consent request");
		}

		return new OAuth2AuthorizationCodeRequestAuthenticationToken(
				authorizationRequest.getAuthorizationUri(), registeredClient.getClientId(), principal, authorizationCode,
				redirectUri, authorizationRequest.getState(), authorizedScopes);
	}

通过里面的OAuth2AuthorizationCode authorizationCode = this.authorizationCodeGenerator.generate(tokenContext);方法生成code,并保存到oauth2_authorization中
后续我们会拿着code去换取token
1723100496754.png
1723100512770.png

经过的过滤器为:OAuth2TokenEndpointFilter
主要方法如下：
	@Override
	protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
			throws ServletException, IOException {

		if (!this.tokenEndpointMatcher.matches(request)) {
			filterChain.doFilter(request, response);
			return;
		}

		try {
		    //获取请求grant_type参数
			String[] grantTypes = request.getParameterValues(OAuth2ParameterNames.GRANT_TYPE);
			if (grantTypes == null || grantTypes.length != 1) {
				throwError(OAuth2ErrorCodes.INVALID_REQUEST, OAuth2ParameterNames.GRANT_TYPE);
			}
            //转化为Authentication,默认为OAuth2AuthorizationCodeAuthenticationToken
			Authentication authorizationGrantAuthentication = this.authenticationConverter.convert(request);
			if (authorizationGrantAuthentication == null) {
				throwError(OAuth2ErrorCodes.UNSUPPORTED_GRANT_TYPE, OAuth2ParameterNames.GRANT_TYPE);
			}
			if (authorizationGrantAuthentication instanceof AbstractAuthenticationToken) {
				((AbstractAuthenticationToken) authorizationGrantAuthentication)
						.setDetails(this.authenticationDetailsSource.buildDetails(request));
			}
            //进行身份验证
			OAuth2AccessTokenAuthenticationToken accessTokenAuthentication =
					(OAuth2AccessTokenAuthenticationToken) this.authenticationManager.authenticate(authorizationGrantAuthentication);
			this.authenticationSuccessHandler.onAuthenticationSuccess(request, response, accessTokenAuthentication);
		} catch (OAuth2AuthenticationException ex) {
			SecurityContextHolder.clearContext();
			if (this.logger.isTraceEnabled()) {
				this.logger.trace(LogMessage.format("Token request failed: %s", ex.getError()), ex);
			}
			this.authenticationFailureHandler.onAuthenticationFailure(request, response, ex);
		}
	}

默认通过OAuth2AuthorizationCodeAuthenticationConverter进行转化请求为OAuth2AuthorizationCodeAuthenticationToken，
后续通过OAuth2AuthorizationCodeAuthenticationProvider进行身份验证,验证逻辑为

	@Override
	public Authentication authenticate(Authentication authentication) throws AuthenticationException {
	    //转化为OAuth2AuthorizationCodeAuthenticationToken
		OAuth2AuthorizationCodeAuthenticationToken authorizationCodeAuthentication =
				(OAuth2AuthorizationCodeAuthenticationToken) authentication;
        //获取客户端的认证信息
		OAuth2ClientAuthenticationToken clientPrincipal =
				getAuthenticatedClientElseThrowInvalidClient(authorizationCodeAuthentication);
		//RegisteredClient
		RegisteredClient registeredClient = clientPrincipal.getRegisteredClient();

		if (this.logger.isTraceEnabled()) {
			this.logger.trace("Retrieved registered client");
		}
        //通过code查询并返回OAuth2Authorization
		OAuth2Authorization authorization = this.authorizationService.findByToken(
				authorizationCodeAuthentication.getCode(), AUTHORIZATION_CODE_TOKEN_TYPE);
		if (authorization == null) {
			throw new OAuth2AuthenticationException(OAuth2ErrorCodes.INVALID_GRANT);
		}

		if (this.logger.isTraceEnabled()) {
			this.logger.trace("Retrieved authorization with authorization code");
		}
        //获取Token,里面包含了code和有效期等信息
		OAuth2Authorization.Token<OAuth2AuthorizationCode> authorizationCode =
				authorization.getToken(OAuth2AuthorizationCode.class);
        //获取OAuth2AuthorizationRequest
		OAuth2AuthorizationRequest authorizationRequest = authorization.getAttribute(
				OAuth2AuthorizationRequest.class.getName());

		if (!registeredClient.getClientId().equals(authorizationRequest.getClientId())) {
			if (!authorizationCode.isInvalidated()) {
				// Invalidate the authorization code given that a different client is attempting to use it
				authorization = OAuth2AuthenticationProviderUtils.invalidate(authorization, authorizationCode.getToken());
				this.authorizationService.save(authorization);
				if (this.logger.isWarnEnabled()) {
					this.logger.warn(LogMessage.format("Invalidated authorization code used by registered client '%s'", registeredClient.getId()));
				}
			}
			throw new OAuth2AuthenticationException(OAuth2ErrorCodes.INVALID_GRANT);
		}

		if (StringUtils.hasText(authorizationRequest.getRedirectUri()) &&
				!authorizationRequest.getRedirectUri().equals(authorizationCodeAuthentication.getRedirectUri())) {
			throw new OAuth2AuthenticationException(OAuth2ErrorCodes.INVALID_GRANT);
		}

		if (!authorizationCode.isActive()) {
			if (authorizationCode.isInvalidated()) {
				OAuth2Token token = authorization.getRefreshToken() != null ?
						authorization.getRefreshToken().getToken() :
						authorization.getAccessToken().getToken();
				if (token != null) {
					// Invalidate the access (and refresh) token as the client is attempting to use the authorization code more than once
					authorization = OAuth2AuthenticationProviderUtils.invalidate(authorization, token);
					this.authorizationService.save(authorization);
					if (this.logger.isWarnEnabled()) {
						this.logger.warn(LogMessage.format("Invalidated authorization token(s) previously issued to registered client '%s'", registeredClient.getId()));
					}
				}
			}
			throw new OAuth2AuthenticationException(OAuth2ErrorCodes.INVALID_GRANT);
		}

		if (this.logger.isTraceEnabled()) {
			this.logger.trace("Validated token request parameters");
		}
        //获取Authentication,默认为UsernamePasswordAuthenticationToken
		Authentication principal = authorization.getAttribute(Principal.class.getName());

		// @formatter:off
		DefaultOAuth2TokenContext.Builder tokenContextBuilder = DefaultOAuth2TokenContext.builder()
				.registeredClient(registeredClient)
				.principal(principal)
				.authorizationServerContext(AuthorizationServerContextHolder.getContext())
				.authorization(authorization)
				.authorizedScopes(authorization.getAuthorizedScopes())
				.authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
				.authorizationGrant(authorizationCodeAuthentication);
		// @formatter:on

		OAuth2Authorization.Builder authorizationBuilder = OAuth2Authorization.from(authorization);

        //用于创建Access token的逻辑
		// ----- Access token -----
		OAuth2TokenContext tokenContext = tokenContextBuilder.tokenType(OAuth2TokenType.ACCESS_TOKEN).build();
		OAuth2Token generatedAccessToken = this.tokenGenerator.generate(tokenContext);
		if (generatedAccessToken == null) {
			OAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.SERVER_ERROR,
					"The token generator failed to generate the access token.", ERROR_URI);
			throw new OAuth2AuthenticationException(error);
		}

		if (this.logger.isTraceEnabled()) {
			this.logger.trace("Generated access token");
		}
        //封装OAuth2AccessToken
		OAuth2AccessToken accessToken = new OAuth2AccessToken(OAuth2AccessToken.TokenType.BEARER,
				generatedAccessToken.getTokenValue(), generatedAccessToken.getIssuedAt(),
				generatedAccessToken.getExpiresAt(), tokenContext.getAuthorizedScopes());
		if (generatedAccessToken instanceof ClaimAccessor) {
			authorizationBuilder.token(accessToken, (metadata) ->
					metadata.put(OAuth2Authorization.Token.CLAIMS_METADATA_NAME, ((ClaimAccessor) generatedAccessToken).getClaims()));
		} else {
			authorizationBuilder.accessToken(accessToken);
		}

		// ----- Refresh token -----
		OAuth2RefreshToken refreshToken = null;
		if (registeredClient.getAuthorizationGrantTypes().contains(AuthorizationGrantType.REFRESH_TOKEN) &&
				// Do not issue refresh token to public client
				!clientPrincipal.getClientAuthenticationMethod().equals(ClientAuthenticationMethod.NONE)) {

			tokenContext = tokenContextBuilder.tokenType(OAuth2TokenType.REFRESH_TOKEN).build();
			OAuth2Token generatedRefreshToken = this.tokenGenerator.generate(tokenContext);
			if (!(generatedRefreshToken instanceof OAuth2RefreshToken)) {
				OAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.SERVER_ERROR,
						"The token generator failed to generate the refresh token.", ERROR_URI);
				throw new OAuth2AuthenticationException(error);
			}

			if (this.logger.isTraceEnabled()) {
				this.logger.trace("Generated refresh token");
			}

			refreshToken = (OAuth2RefreshToken) generatedRefreshToken;
			authorizationBuilder.refreshToken(refreshToken);
		}

		// ----- ID token -----
		OidcIdToken idToken;
		if (authorizationRequest.getScopes().contains(OidcScopes.OPENID)) {
			SessionInformation sessionInformation = getSessionInformation(principal);
			if (sessionInformation != null) {
				try {
					// Compute (and use) hash for Session ID
					sessionInformation = new SessionInformation(sessionInformation.getPrincipal(),
							createHash(sessionInformation.getSessionId()), sessionInformation.getLastRequest());
				} catch (NoSuchAlgorithmException ex) {
					OAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.SERVER_ERROR,
							"Failed to compute hash for Session ID.", ERROR_URI);
					throw new OAuth2AuthenticationException(error);
				}
				tokenContextBuilder.put(SessionInformation.class, sessionInformation);
			}
			// @formatter:off
			tokenContext = tokenContextBuilder
					.tokenType(ID_TOKEN_TOKEN_TYPE)
					.authorization(authorizationBuilder.build())	// ID token customizer may need access to the access token and/or refresh token
					.build();
			// @formatter:on
			OAuth2Token generatedIdToken = this.tokenGenerator.generate(tokenContext);
			if (!(generatedIdToken instanceof Jwt)) {
				OAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.SERVER_ERROR,
						"The token generator failed to generate the ID token.", ERROR_URI);
				throw new OAuth2AuthenticationException(error);
			}

			if (this.logger.isTraceEnabled()) {
				this.logger.trace("Generated id token");
			}

			idToken = new OidcIdToken(generatedIdToken.getTokenValue(), generatedIdToken.getIssuedAt(),
					generatedIdToken.getExpiresAt(), ((Jwt) generatedIdToken).getClaims());
			authorizationBuilder.token(idToken, (metadata) ->
					metadata.put(OAuth2Authorization.Token.CLAIMS_METADATA_NAME, idToken.getClaims()));
		} else {
			idToken = null;
		}

		authorization = authorizationBuilder.build();

		// Invalidate the authorization code as it can only be used once
		authorization = OAuth2AuthenticationProviderUtils.invalidate(authorization, authorizationCode.getToken());
        //保存OAuth2Authorization
		this.authorizationService.save(authorization);

		if (this.logger.isTraceEnabled()) {
			this.logger.trace("Saved authorization");
		}

		Map<String, Object> additionalParameters = Collections.emptyMap();
		if (idToken != null) {
			additionalParameters = new HashMap<>();
			additionalParameters.put(OidcParameterNames.ID_TOKEN, idToken.getTokenValue());
		}

		if (this.logger.isTraceEnabled()) {
			this.logger.trace("Authenticated token request");
		}
        //返回OAuth2AccessTokenAuthenticationToken
		return new OAuth2AccessTokenAuthenticationToken(
				registeredClient, clientPrincipal, accessToken, refreshToken, additionalParameters);
	}
上面处理完成之后，该OAuth2AccessTokenAuthenticationToken里面封装了accessToken,refreshToken等信息
调用OAuth2TokenEndpointFilter#sendAccessTokenResponse方法进行响应

	private void sendAccessTokenResponse(HttpServletRequest request, HttpServletResponse response,
			Authentication authentication) throws IOException {

		OAuth2AccessTokenAuthenticationToken accessTokenAuthentication =
				(OAuth2AccessTokenAuthenticationToken) authentication;

		OAuth2AccessToken accessToken = accessTokenAuthentication.getAccessToken();
		OAuth2RefreshToken refreshToken = accessTokenAuthentication.getRefreshToken();
		Map<String, Object> additionalParameters = accessTokenAuthentication.getAdditionalParameters();

		OAuth2AccessTokenResponse.Builder builder =
				OAuth2AccessTokenResponse.withToken(accessToken.getTokenValue())
						.tokenType(accessToken.getTokenType())
						.scopes(accessToken.getScopes());
		if (accessToken.getIssuedAt() != null && accessToken.getExpiresAt() != null) {
			builder.expiresIn(ChronoUnit.SECONDS.between(accessToken.getIssuedAt(), accessToken.getExpiresAt()));
		}
		if (refreshToken != null) {
			builder.refreshToken(refreshToken.getTokenValue());
		}
		if (!CollectionUtils.isEmpty(additionalParameters)) {
			builder.additionalParameters(additionalParameters);
		}
		OAuth2AccessTokenResponse accessTokenResponse = builder.build();
		ServletServerHttpResponse httpResponse = new ServletServerHttpResponse(response);
		this.accessTokenHttpResponseConverter.write(accessTokenResponse, null, httpResponse);
	}

最终通过OAuth2AccessTokenResponseHttpMessageConverter写入到响应中

通过携带token进行访问即可
1723100968224.png
